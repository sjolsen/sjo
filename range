// -*- mode: c++; -*-

#ifndef SJO_RANGE_HEADER
#define SJO_RANGE_HEADER

#include <utility>

namespace sjo
{

template <typename Iterator>
struct range_wrapper_type
{
	Iterator _begin;
	Iterator _end;

	constexpr
	range_wrapper_type (Iterator first, Iterator last = Iterator {})
		: _begin (std::move (first)),
		  _end (std::move (last))
	{
	}

	constexpr
	Iterator begin () const
	{
		return _begin;
	}

	constexpr
	Iterator end () const
	{
		return _end;
	}
};

template <typename Iterator>
inline
range_wrapper_type <Iterator> range (Iterator first, Iterator last)
{
	return range_wrapper_type <Iterator> (std::move (first),
	                                      std::move (last));
}

} // namespace sjo



#include <iterator>

namespace sjo
{

template <typename Integer>
struct int_iterator
	: std::iterator <std::input_iterator_tag,
	                 Integer,
	                 decltype (Integer {} - Integer {})>
{
	using iterator = std::iterator <std::input_iterator_tag,
	                 Integer,
                         decltype (Integer {} - Integer {})>;

	using typename iterator::value_type;
	using typename iterator::difference_type;
	using typename iterator::pointer;
	using typename iterator::reference;
	using typename iterator::iterator_category;

	value_type _value;

	constexpr
	int_iterator (value_type value)
		: _value (value)
	{
	}

	int_iterator& operator ++()
	{
		++_value;
		return *this;
	}

	constexpr
	value_type operator *()
	{
		return _value;
	}

	constexpr
	bool operator == (int_iterator other)
	{
		return _value == other._value;
	}

	constexpr
	bool operator != (int_iterator other)
	{
		return _value != other._value;
	}
};

// range_wrapper_type <int_iterator <Integral>>
// range (Integral first, Integral last)
// {
// 	return {first, last};
// }

#define SJO_DEFINE_RANGE_INT(type)                                              \
inline constexpr                                                                \
range_wrapper_type <int_iterator <type>> range (type first,                     \
                                                type last)                      \
{                                                                               \
	return {first, last};                                                   \
}

// Overload for all integral types
SJO_DEFINE_RANGE_INT (bool)

SJO_DEFINE_RANGE_INT (char)
SJO_DEFINE_RANGE_INT (signed char)
SJO_DEFINE_RANGE_INT (unsigned char)

SJO_DEFINE_RANGE_INT (wchar_t)
SJO_DEFINE_RANGE_INT (char16_t)
SJO_DEFINE_RANGE_INT (char32_t)

SJO_DEFINE_RANGE_INT (short int)
SJO_DEFINE_RANGE_INT (unsigned short int)

SJO_DEFINE_RANGE_INT (int)
SJO_DEFINE_RANGE_INT (unsigned int)

SJO_DEFINE_RANGE_INT (long int)
SJO_DEFINE_RANGE_INT (unsigned long int)

SJO_DEFINE_RANGE_INT (long long int)
SJO_DEFINE_RANGE_INT (unsigned long long int)



template <typename Container>
inline sjo::range_wrapper_type <typename Container::iterator>
range (Container& _container)
{
	using std::begin;
	using std::end;
	return {begin (_container), end (_container)};
}

template <typename Container>
inline sjo::range_wrapper_type <typename Container::const_iterator>
range (const Container& _container)
{
	using std::begin;
	using std::end;
	return {begin (_container), end (_container)};
}

template <typename T>
inline sjo::range_wrapper_type <typename std::initializer_list <T>::iterator>
range (const std::initializer_list <T>& _list)
{
	return {_list.begin (), _list.end ()};
}



// Overload for std::istream et al.
template <typename T, typename CharT>
inline sjo::range_wrapper_type <std::istream_iterator <T>>
range (std::basic_istream <CharT>& is)
{
	return {std::istream_iterator <T> (is), {}};
}

template <typename CharT>
inline sjo::range_wrapper_type <std::istreambuf_iterator <CharT>>
range (std::basic_istream <CharT>& is)
{
	return {std::istreambuf_iterator <CharT> (is), {}};
}

} // namespace sjo

#endif // SJO_RANGE_HEADER
